// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.4;

/*
    Simple form of cryptocurrency.
    Only creator can create coins.
    Anyone can transfer coins to other addresses.
*/

contract Coin {
    // The keyword "public" makes variables
    // accessible from other contracts
    address public minter; // the compiler sees address and does: 'function minter() external view returns (address) { return minter; }'
    mapping (address => uint) public balances; // mapping is like a hashmap, address is the key, uint is the value
    
    /*
    getter function generated by the public keyword
    can be used to retrieve the balance of a single address
    
  
    function balances(address _account) external view returns (uint) {
    return balances[_account];
    }
    */

    // Events allow clients to react to specific
    // contract changes you declare
    // Clients/webapps can subscribe to events for low cost
    event Sent(address from, address to, uint amount);

    /*
    Could listen via web3.js

    Coin.Sent().watch({}, '', function(error, result) {
        if (!error) {
            console.log("Coin transfer: " + result.args.amount +
                " coins were sent from " + result.args.from +
                " to " + result.args.to + ".");
            console.log("Balances now:\n" +
                "Sender: " + Coin.balances.call(result.args.from) +
                "Receiver: " + Coin.balances.call(result.args.to));
        }
    })
    */

    // Constructor code is only run when the contract
    // is created
    // msg is a special global variable that allows access to the blockchain 
    constructor() {
        minter = msg.sender; // msg.sender is where the current external function is being called from 
    }

    // Sends an amount of newly created coins to an address
    // Can only be called by the contract creator
    function mint(address receiver, uint amount) public {
        require(msg.sender == minter); // require() reverts changes if the condition is not met
        balances[receiver] += amount; // if overflow (exceeds 2**256-1) auto reverts 
    }

    // Errors allow you to provide information about
    // why an operation failed. They are returned
    // to the caller of the function.
    error InsufficientBalance(uint requested, uint available);

    // Sends an amount of existing coins
    // from any caller to an address
    function send(address receiver, uint amount) public {
        if (amount > balances[msg.sender])
            revert InsufficientBalance({
                requested: amount,
                available: balances[msg.sender]
            });

        balances[msg.sender] -= amount;
        balances[receiver] += amount;
        emit Sent(msg.sender, receiver, amount);
    }
}